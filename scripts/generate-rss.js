#!/usr/bin/env node
/**
 * RSS Feed Generator for Devon's Blog
 * 
 * RSC-Native Implementation:
 * This script reads pre-extracted blog metadata from feed-data.html,
 * which is generated by Parcel's RSC system using the same `pages` prop
 * that powers the blog navigation (Nav.tsx).
 * 
 * This ensures a single source of truth for metadata - Parcel extracts
 * the metadata once, and both the Nav component and RSS feed use it.
 * 
 * Note: RSS readers identify unique entries by the <guid> element.
 * Each post has a stable GUID based on its URL, so rebuilding the feed
 * will not cause duplicate entries in RSS clients.
 */

const fs = require('fs');
const path = require('path');

const SITE_URL = 'https://devongovett.me';
const SITE_TITLE = "Devon's Blog";
const SITE_DESCRIPTION = "Devon Govett's blog about JavaScript, bundlers, and web development";

const distDir = path.join(__dirname, '../dist');
const feedDataPath = path.join(distDir, 'feed-data.html');
const blogDir = path.join(__dirname, '../src/pages/blog');

/**
 * Extract JSON data from the RSC-generated feed-data.html page
 */
function extractFeedDataFromHtml(html) {
  // Extract JSON from <script id=feed-data type=application/json>...</script>
  // Note: Parcel outputs unquoted attributes, so we match both quoted and unquoted
  const match = html.match(/<script[^>]*id=["']?feed-data["']?[^>]*type=["']?application\/json["']?[^>]*>([\s\S]*?)<\/script>/i);
  if (!match) {
    return null;
  }
  try {
    return JSON.parse(match[1]);
  } catch (e) {
    console.warn('⚠ Failed to parse feed data JSON:', e.message);
    return null;
  }
}

/**
 * Fallback: Extract metadata directly from MDX files (legacy approach)
 * Used when feed-data.html is not available (e.g., first build)
 */
function extractMetadataFromMdx(content, filename) {
  const metadata = {};
  
  // Extract exported constants (description, date)
  const descMatch = content.match(/export\s+const\s+description\s*=\s*(['"`])((?:\\.|(?!\1).)*)\1/s);
  const dateMatch = content.match(/export\s+const\s+date\s*=\s*(['"`])(.+?)\1/);
  
  // Extract title from first H1
  const titleMatch = content.match(/^#\s+(.+)$/m);
  
  if (descMatch) {
    metadata.description = descMatch[2]
      .replace(/\\'/g, "'")
      .replace(/\\"/g, '"')
      .replace(/\\\\/g, '\\');
  }
  if (dateMatch) metadata.date = dateMatch[2];
  if (titleMatch) metadata.title = titleMatch[1];
  
  // Generate URL from filename
  const slug = filename.replace(/\.mdx$/, '');
  metadata.url = `/blog/${slug}.html`;
  metadata.slug = slug;
  
  return metadata;
}

/**
 * Get blog posts from MDX files (fallback method)
 */
function getPostsFromMdx() {
  const files = fs.readdirSync(blogDir).filter(f => f.endsWith('.mdx'));
  
  return files.map(file => {
    const content = fs.readFileSync(path.join(blogDir, file), 'utf-8');
    return extractMetadataFromMdx(content, file);
  }).filter(post => post.title && post.date);
}

function escapeXml(str) {
  if (!str) return '';
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;');
}

function generateRSS(posts) {
  const now = new Date().toUTCString();
  
  const items = posts
    .sort((a, b) => new Date(b.date) - new Date(a.date))
    .map(post => {
      const fullUrl = post.url.startsWith('http') ? post.url : `${SITE_URL}${post.url}`;
      return `    <item>
      <title>${escapeXml(post.title)}</title>
      <link>${fullUrl}</link>
      <guid isPermaLink="true">${fullUrl}</guid>
      <description>${escapeXml(post.description)}</description>
      <pubDate>${new Date(post.date + 'T00:00:00Z').toUTCString()}</pubDate>
    </item>`;
    })
    .join('\n');

  return `<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>${escapeXml(SITE_TITLE)}</title>
    <link>${SITE_URL}</link>
    <description>${escapeXml(SITE_DESCRIPTION)}</description>
    <language>en-us</language>
    <lastBuildDate>${now}</lastBuildDate>
    <atom:link href="${SITE_URL}/feed.xml" rel="self" type="application/rss+xml"/>
${items}
  </channel>
</rss>`;
}

function main() {
  let posts;
  let source;
  
  // Try to use RSC-generated feed data first (preferred, RSC-native approach)
  if (fs.existsSync(feedDataPath)) {
    const html = fs.readFileSync(feedDataPath, 'utf-8');
    const feedData = extractFeedDataFromHtml(html);
    
    if (feedData && Array.isArray(feedData) && feedData.length > 0) {
      posts = feedData;
      source = 'RSC feed-data.html';
    }
  }
  
  // Fallback to parsing MDX files directly (for backwards compatibility)
  if (!posts) {
    console.log('ℹ feed-data.html not found or empty, falling back to MDX parsing...');
    posts = getPostsFromMdx();
    source = 'MDX files (fallback)';
  }

  // Deduplicate posts by slug
  const seenSlugs = new Set();
  const uniquePosts = posts.filter(post => {
    const slug = post.slug || post.url.replace(/^\/blog\//, '').replace(/\.html$/, '');
    if (seenSlugs.has(slug)) {
      console.warn(`⚠ Skipping duplicate post: ${slug}`);
      return false;
    }
    seenSlugs.add(slug);
    return true;
  });

  const rss = generateRSS(uniquePosts);
  
  // Ensure dist directory exists
  if (!fs.existsSync(distDir)) {
    fs.mkdirSync(distDir, { recursive: true });
  }
  
  // Write feed.xml
  const feedPath = path.join(distDir, 'feed.xml');
  fs.writeFileSync(feedPath, rss, 'utf-8');
  
  console.log(`✓ Generated RSS feed with ${uniquePosts.length} posts (source: ${source})`);
}

main();
