#!/usr/bin/env node
/**
 * RSS Feed Generator for Devon's Blog
 * 
 * RSC-Native Implementation:
 * This script reads pre-extracted blog metadata from feed-data.html,
 * which is generated by Parcel's RSC system using the same `pages` prop
 * that powers the blog navigation (Nav.tsx).
 * 
 * This ensures a single source of truth for metadata - Parcel extracts
 * the metadata once, and both the Nav component and RSS feed use it.
 * 
 * Usage: Run after `parcel build` to generate feed.xml
 * 
 * Note: RSS readers identify unique entries by the <guid> element.
 * Each post has a stable GUID based on its URL, so rebuilding the feed
 * will not cause duplicate entries in RSS clients.
 */

const fs = require('fs');
const path = require('path');

const SITE_URL = 'https://devongovett.me';
const SITE_TITLE = "Devon's Blog";
const SITE_DESCRIPTION = "Devon Govett's blog about JavaScript, bundlers, and web development";

const distDir = path.join(__dirname, '../dist');
const feedDataPath = path.join(distDir, 'feed-data.html');

/**
 * Extract JSON data from the RSC-generated feed-data.html page
 */
function extractFeedDataFromHtml(html) {
  // Extract JSON from <script id=feed-data type=application/json>...</script>
  // Note: Parcel outputs unquoted attributes, so we match both quoted and unquoted
  const match = html.match(/<script[^>]*id=["']?feed-data["']?[^>]*type=["']?application\/json["']?[^>]*>([\s\S]*?)<\/script>/i);
  if (!match) {
    return null;
  }
  try {
    return JSON.parse(match[1]);
  } catch (e) {
    console.warn('⚠ Failed to parse feed data JSON:', e.message);
    return null;
  }
}

function escapeXml(str) {
  if (!str) return '';
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;');
}

function generateRSS(posts) {
  const now = new Date().toUTCString();
  
  const items = posts
    .sort((a, b) => new Date(b.date) - new Date(a.date))
    .map(post => {
      const fullUrl = post.url.startsWith('http') ? post.url : `${SITE_URL}${post.url}`;
      return `    <item>
      <title>${escapeXml(post.title)}</title>
      <link>${fullUrl}</link>
      <guid isPermaLink="true">${fullUrl}</guid>
      <description>${escapeXml(post.description)}</description>
      <pubDate>${new Date(post.date + 'T00:00:00Z').toUTCString()}</pubDate>
    </item>`;
    })
    .join('\n');

  return `<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>${escapeXml(SITE_TITLE)}</title>
    <link>${SITE_URL}</link>
    <description>${escapeXml(SITE_DESCRIPTION)}</description>
    <language>en-us</language>
    <lastBuildDate>${now}</lastBuildDate>
    <atom:link href="${SITE_URL}/feed.xml" rel="self" type="application/rss+xml"/>
${items}
  </channel>
</rss>`;
}

function main() {
  // Read RSC-generated feed data (built by Parcel from feed-data.tsx)
  if (!fs.existsSync(feedDataPath)) {
    console.error('✗ feed-data.html not found. Run "parcel build" first.');
    process.exit(1);
  }
  
  const html = fs.readFileSync(feedDataPath, 'utf-8');
  const posts = extractFeedDataFromHtml(html);
  
  if (!posts || !Array.isArray(posts) || posts.length === 0) {
    console.error('✗ Failed to extract feed data from feed-data.html');
    process.exit(1);
  }

  // Deduplicate posts by slug
  const seenSlugs = new Set();
  const uniquePosts = posts.filter(post => {
    const slug = post.slug || post.url.replace(/^\/blog\//, '').replace(/\.html$/, '');
    if (seenSlugs.has(slug)) {
      console.warn(`⚠ Skipping duplicate post: ${slug}`);
      return false;
    }
    seenSlugs.add(slug);
    return true;
  });

  const rss = generateRSS(uniquePosts);
  
  // Ensure dist directory exists
  if (!fs.existsSync(distDir)) {
    fs.mkdirSync(distDir, { recursive: true });
  }
  
  // Write feed.xml
  const feedPath = path.join(distDir, 'feed.xml');
  fs.writeFileSync(feedPath, rss, 'utf-8');
  
  console.log(`✓ Generated RSS feed with ${uniquePosts.length} posts`);
}

main();
